name: Frontend CI/CD Pipeline (Targeted with Rollback)
on:
  push:
    branches:
      - main

jobs:
  deploy_frontend:
    runs-on: ubuntu-latest
    
    steps:
      - name: 1. Checkout Frontend Repo
        uses: actions/checkout@v4
        with:
          path: frontend

      - name: 2. Deploy via SSH with Rollback Logic
        # Define the secret variable for the step.
        env:
          DOTENV_CONTENT: ${{ secrets.DOTENV_CONTENT }}
          
        uses: appleboy/ssh-action@v1.0.3
        
        # 'with:' must be indented under 'uses:'
        with:
          host: ${{ secrets.HOST_IP }}
          username: ${{ secrets.HOST_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          
          # 'script:' must be indented under 'with:'
          script: |
            # --- CONFIG: REPLACE THESE PATHS WITH YOUR ACTUAL SERVER PATHS ---
            PROJECT_DIR=~/industrialmart-deployment
            FRONTEND_DIR=$PROJECT_DIR/e-commerce-app-frontend
            FRONTEND_SERVICE_NAME="frontend" 
            FRONTEND_CONTAINER_NAME="frontend-app" 
            ROLLBACK_TAG="${FRONTEND_SERVICE_NAME}-backup-$(date +%s)"
            # ----------------------------------------------------------------

            echo "Starting targeted deployment with rollback capability..."
            
            # Function to execute rollback if deployment fails
            rollback() {
                echo "!!! Deployment FAILED. Initiating Rollback !!!"
                cd $PROJECT_DIR
                docker compose stop $FRONTEND_SERVICE_NAME nginx
                docker compose rm -f $FRONTEND_SERVICE_NAME nginx
                
                echo "Restoring image $ROLLBACK_TAG to the primary tag..."
                docker tag $FRONTEND_SERVICE_NAME:$ROLLBACK_TAG $FRONTEND_SERVICE_NAME:latest
                
                echo "Redeploying the previous working version..."
                docker compose up -d --no-deps $FRONTEND_SERVICE_NAME nginx
                
                echo "Rollback Complete. The previous working version is now live."
                exit 1
            }
            
            # Navigate to the main project directory
            cd $PROJECT_DIR
            
            # --- CRITICAL FIX: INJECT SECRETS DIRECTLY INTO THE SHELL ---
            # This is the most reliable way to pass multi-line secrets to Docker Compose.
            echo "1. Injecting secrets directly into the shell environment..."
            # This pipes the multi-line secret string through sed to prepend 'export ' to every line,
            # then executes the resulting lines as shell commands.
            echo "$DOTENV_CONTENT" | sed 's/^/export /' | bash
            echo "Secrets are now available in the shell environment."
            # -------------------------------------------------------------
            
            # 2. Backup current image (using the robust status check from previous steps)
            echo "2. Saving current working image for potential rollback..."
            CURRENT_IMAGE_ID=$(docker inspect --format='{{.Image}}' $FRONTEND_CONTAINER_NAME 2>/dev/null)

            if [ -n "$CURRENT_IMAGE_ID" ]; then
                docker tag $CURRENT_IMAGE_ID $FRONTEND_SERVICE_NAME:$ROLLBACK_TAG
                echo "Backup saved as $FRONTEND_SERVICE_NAME:$ROLLBACK_TAG"
            else
                echo "Warning: Could not find a running frontend container. Proceeding without backup."
            fi
            
            # 3. PULL LATEST CODE & DEPLOY
            echo "3. Updating Frontend code in $FRONTEND_DIR and deploying..."
            cd $FRONTEND_DIR
            git pull origin main 
            
            cd $PROJECT_DIR
            # Deploy the new version. Docker Compose inherits variables from the shell.
            docker compose up -d --no-deps --build $FRONTEND_SERVICE_NAME nginx || { echo "Docker Compose UP failed immediately." && rollback; }

            # 4. HEALTH CHECK
            echo "4. Running basic health check (waiting 15 seconds for startup)..."
            sleep 15
            
            STATUS=$(docker inspect --format='{{.State.Status}}' $FRONTEND_CONTAINER_NAME 2>/dev/null)
            
            if [ "$STATUS" == "running" ]; then
                echo "Deployment successful. Frontend service is running."
                
                # 5. CLEANUP
                if [ -n "$CURRENT_IMAGE_ID" ]; then
                    docker rmi $FRONTEND_SERVICE_NAME:$ROLLBACK_TAG 2>/dev/null || true
                    echo "Successfully cleaned up temporary backup tag."
                fi
            else
                echo "Health check FAILED. Container status: $STATUS"
                rollback
            fi
