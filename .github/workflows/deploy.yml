name: üê≥ Docker Build, Push, and Deploy (Next.js)

on:
  push:
    branches:
      - main # Trigger on push to the main branch

# Environment variables used throughout the workflow
env:
  IMAGE_NAME: ecommerce-frontend # Change this to your application name
  REGISTRY: ghcr.io # Using GitHub Container Registry
  DOCKER_COMPOSE_PATH: /home/deployer/industrialmart-deployment/docker-compose.yml # Path to the compose file on your server
  # NOTE: Update the service name below to match what's in your docker-compose.yml
  DOCKER_SERVICE_NAME: frontend # Example: The name of the service running this image
  SERVER_USER_HOST: deployer@138.199.204.95 # Change this to your actual user@host

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      # Expose the generated tags so the deploy job can use them
      tags: ${{ steps.meta.outputs.tags }}
      sha_tag: ${{ steps.get_sha_tag.outputs.sha_tag }} # The unique tag for rollback
    
    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4

      - name: üîë Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # Automatically provided secret

      - name: üè∑Ô∏è Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=sha-,format=short # Unique tag using the commit SHA
            type=raw,value=latest,enable=true # Always tag the latest build
            
      - name: üî® Build and Push Docker image (with Secrets)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          
          # üö® Passing the NEXT_PUBLIC ARGs from GitHub Secrets to the Dockerfile üö®
          build-args: |
            NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
            NEXT_PUBLIC_IMAGE_BASE_URL=${{ secrets.NEXT_PUBLIC_IMAGE_BASE_URL }}
            NEXT_PUBLIC_API_BASE_URL=${{ secrets.NEXT_PUBLIC_API_BASE_URL }}
            
      - name: üìÑ Get unique SHA tag for deployment
        id: get_sha_tag
        run: |
          # Finds the unique SHA tag generated by the metadata action
          SHA_TAG=$(echo "${{ steps.meta.outputs.tags }}" | grep 'sha-')
          echo "sha_tag=$SHA_TAG" >> $GITHUB_OUTPUT

---

  deploy:
    needs: build-and-push # Ensures build is complete
    runs-on: ubuntu-latest
    environment: production # Use an environment for protection/secrets
    
    steps:
      - name: üîë Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          # SSH_PRIVATE_KEY is a secret you must add to your repository
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }} 

      - name: üö¢ Deploy and Rollback Script Execution
        run: |
          # Construct the full image path with the unique SHA tag
          IMAGE_PATH="${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.sha_tag }}"
          SERVICE_NAME="${{ env.DOCKER_SERVICE_NAME }}"
          SERVER_USER_HOST="${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}"

          echo "Attempting to deploy image: $IMAGE_PATH"

          # 1. Connect to the server and execute the deployment script
          # The 'EOF' must be quoted 'EOF' to prevent local shell variable substitution
          ssh -o StrictHostKeyChecking=no $SERVER_USER_HOST << 'EOF'
            
            # --- START SCRIPT ON REMOTE SERVER ---
            
            DEPLOY_DIR=$(dirname ${{ env.DOCKER_COMPOSE_PATH }})
            COMPOSE_FILE=$(basename ${{ env.DOCKER_COMPOSE_PATH }})
            
            cd $DEPLOY_DIR
            
            # File to store the previously stable image tag
            PREVIOUS_TAG_FILE="$DEPLOY_DIR/previous_stable_tag.txt"
            
            # Get the previous running tag (the one we will roll back to if new deployment fails)
            if [ -f "$PREVIOUS_TAG_FILE" ]; then
              PREVIOUS_TAG=$(cat "$PREVIOUS_TAG_FILE")
            else
              PREVIOUS_TAG="latest" # Fallback tag
            fi
            
            echo "Previous stable tag: $PREVIOUS_TAG"
            
            # Save the new unique tag as the current stable tag (will be used as rollback if next deploy fails)
            echo "${{ needs.build-and-push.outputs.sha_tag }}" > "$PREVIOUS_TAG_FILE"

            # --- DEPLOY NEW VERSION ---
            
            # Pull the new image (it needs to be pulled from GHCR)
            docker pull $IMAGE_PATH
            
            # Use 'sed' to update the image tag in the docker-compose file
            # CAUTION: The pattern below assumes your image line looks like:
            # image: ghcr.io/user/repo/my-frontend-app:tag
            sed -i "s|image: .*/${{ env.IMAGE_NAME }}:.*|image: $IMAGE_PATH|" "$COMPOSE_FILE"
            
            echo "Starting new deployment for service: $SERVICE_NAME"
            
            # Bring up the new service
            docker compose -f "$COMPOSE_FILE" up -d --no-deps $SERVICE_NAME

            # --- HEALTH CHECK (CRITICAL FOR ROLLBACK) ---
            
            sleep 15 # Wait for Next.js server to start
            
            # Replace 'http://localhost:3000/health' with your actual health check endpoint and port
            HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000) 
            
            if [ "$HEALTH_STATUS" -eq 200 ]; then
              echo "‚úÖ Deployment successful! Health check passed (HTTP 200)."
            else
              echo "‚ùå Health check failed (HTTP $HEALTH_STATUS). Initiating rollback..."
              
              # --- ROLLBACK ---
              
              # Construct the rollback image path
              ROLLBACK_IMAGE="${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:$PREVIOUS_TAG"
              
              echo "Rolling back to image: $ROLLBACK_IMAGE"
              
              # Pull the previous stable image
              docker pull $ROLLBACK_IMAGE
              
              # Update the docker-compose file with the previous stable tag
              sed -i "s|image: .*/${{ env.IMAGE_NAME }}:.*|image: $ROLLBACK_IMAGE|" "$COMPOSE_FILE"
              
              # Redeploy the previous stable service
              docker compose -f "$COMPOSE_FILE" up -d --no-deps $SERVICE_NAME
              
              echo "Rollback complete."
              exit 1 # Exit with non-zero code to fail the GitHub Action
            fi
            
            # --- END SCRIPT ON REMOTE SERVER ---
          EOF