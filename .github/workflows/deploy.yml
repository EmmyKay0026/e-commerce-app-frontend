name: üê≥ Docker Build, Push, and Deploy (Next.js)

on:
  push:
    branches:
      - main # Trigger on push to the main branch

# üö® Ensure this block is present and correct üö®
permissions:
  contents: read # Required for actions/checkout
  packages: write # Required for pushing to ghcr.io

# Environment variables used throughout the workflow
env:
  IMAGE_NAME: ecommerce-frontend # Change this to your application name
  REGISTRY: ghcr.io # Using GitHub Container Registry
  DOCKER_COMPOSE_PATH: /home/deployer/industrialmart-deployment/docker-compose.yml # Path to the compose file on your server
  # NOTE: Update the service name below to match what's in your docker-compose.yml
  DOCKER_SERVICE_NAME: frontend # Example: The name of the service running this image
  SERVER_USER_HOST: deployer@138.199.204.95 # Change this to your actual user@host

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      # Expose the generated tags so the deploy job can use them
      tags: ${{ steps.meta.outputs.tags }}
      sha_tag: ${{ steps.get_sha_tag.outputs.sha_tag }} # The unique tag for rollback

    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4

      - name: üì¶ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîë Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # Automatically provided secret

      - name: üè∑Ô∏è Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=sha-,format=short # Unique tag using the commit SHA
            type=raw,value=latest,enable=true # Always tag the latest build

      - name: üî® Build and Push Docker image (with Secrets)
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

          # üö® Passing the NEXT_PUBLIC ARGs from GitHub Secrets to the Dockerfile üö®
          build-args: |
            NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
            NEXT_PUBLIC_IMAGE_BASE_URL=${{ secrets.NEXT_PUBLIC_IMAGE_BASE_URL }}
            NEXT_PUBLIC_API_BASE_URL=${{ secrets.NEXT_PUBLIC_API_BASE_URL }}

      - name: üìÑ Get unique SHA tag for deployment
        id: get_sha_tag
        run: |
          # Finds the unique SHA tag generated by the metadata action
          SHA_TAG=$(echo "${{ steps.meta.outputs.tags }}" | grep 'sha-')
          echo "sha_tag=$SHA_TAG" >> $GITHUB_OUTPUT

  deploy:
    needs: build-and-push # Ensures build is complete
    runs-on: ubuntu-latest
    environment: production # Use an environment for protection/secrets

    steps:
      - name: üîë Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          # SSH_PRIVATE_KEY is a secret you must add to your repository
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: üö¢ Deploy and Rollback Script Execution
        run: |
          # GHCR requires lowercase repository names
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_PATH="${{ env.REGISTRY }}/$REPO_LOWER/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.sha_tag }}"
          SERVICE_NAME="${{ env.DOCKER_SERVICE_NAME }}"
          SERVER_USER_HOST="${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}"

          echo "Attempting to deploy image: $IMAGE_PATH"

          # 1. Connect to the server and execute the deployment script
          # The 'EOF' must be quoted 'EOF' to prevent local shell variable substitution
          ssh -o StrictHostKeyChecking=no $SERVER_USER_HOST << EOF
            set -e # Exit immediately if a command exits with a non-zero status
            
            # --- START SCRIPT ON REMOTE SERVER ---
            
            DEPLOY_DIR=\$(dirname ${{ env.DOCKER_COMPOSE_PATH }})
            COMPOSE_FILE=\$(basename ${{ env.DOCKER_COMPOSE_PATH }})
            
            cd \$DEPLOY_DIR
            
            # üîë Log in to GitHub Container Registry on the VPS
            # Using the GITHUB_TOKEN passed via environment or secret if needed, 
            # but usually, you'd use a Personal Access Token (PAT) for VPS login.
            # Here we assume the user has set CR_PAT secret.
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

            # File to store the previously stable image tag
            PREVIOUS_TAG_FILE="\$DEPLOY_DIR/previous_stable_tag.txt"
            
            # Get the previous running tag (the one we will roll back to if new deployment fails)
            if [ -f "\$PREVIOUS_TAG_FILE" ]; then
              PREVIOUS_TAG=\$(cat "\$PREVIOUS_TAG_FILE")
            else
              PREVIOUS_TAG="latest" # Fallback tag
            fi
            
            echo "Previous stable tag: \$PREVIOUS_TAG"
            
            # Save the new unique tag as the current stable tag (will be used as rollback if next deploy fails)
            echo "${{ needs.build-and-push.outputs.sha_tag }}" > "\$PREVIOUS_TAG_FILE"

            # --- DEPLOY NEW VERSION ---
            
            # Pull the new image (it needs to be pulled from GHCR)
            docker pull $IMAGE_PATH
            
            # Use 'sed' to update the image tag in the docker-compose file
            # Robust replacement targeting the specific service and image key
            sed -i "s|image: .*/${{ env.IMAGE_NAME }}:.*|image: $IMAGE_PATH|" "\$COMPOSE_FILE"
            
            echo "Starting new deployment for service: \$SERVICE_NAME"
            
            # Bring up the new service
            docker compose -f "\$COMPOSE_FILE" up -d --no-deps \$SERVICE_NAME

            # --- HEALTH CHECK ---
            
            echo "Waiting for health check..."
            sleep 20 # Wait for Next.js server to start
            
            # Health check on localhost inside the VPS
            # Port should match what's exposed in docker-compose for the host
            HEALTH_STATUS=\$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 || echo "failed") 
            
            if [ "\$HEALTH_STATUS" = "200" ]; then
              echo "‚úÖ Deployment successful! Health check passed (HTTP 200)."
            else
              echo "‚ùå Health check failed (HTTP \$HEALTH_STATUS). Initiating rollback..."
              
              # --- ROLLBACK ---
              
              ROLLBACK_IMAGE="${{ env.REGISTRY }}/$REPO_LOWER/${{ env.IMAGE_NAME }}:\$PREVIOUS_TAG"
              
              echo "Rolling back to image: \$ROLLBACK_IMAGE"
              
              # Pull the previous stable image
              docker pull \$ROLLBACK_IMAGE
              
              # Update the docker-compose file with the previous stable tag
              sed -i "s|image: .*/${{ env.IMAGE_NAME }}:.*|image: \$ROLLBACK_IMAGE|" "\$COMPOSE_FILE"
              
              # Redeploy the previous stable service
              docker compose -f "\$COMPOSE_FILE" up -d --no-deps \$SERVICE_NAME
              
              echo "Rollback complete."
              exit 1 
            fi
            
            # --- END SCRIPT ON REMOTE SERVER ---
EOF
